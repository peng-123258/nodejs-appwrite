name: 检查并重新部署 Appwrite Site

on:
  schedule:
    - cron: '*/15 * * * *' # 每15分钟自动运行一次
  workflow_dispatch: # 允许手动触发

jobs:
  check-and-redeploy:
    runs-on: ubuntu-latest
    env:
      APPWRITE_PROJECT_ID: ${{ secrets.APPWRITE_PROJECT_ID }}
      APPWRITE_SITE_ID: ${{ secrets.APPWRITE_SITE_ID }}
      APPWRITE_REPO_ID: ${{ secrets.APPWRITE_REPO_ID }}
      APPWRITE_API_ENDPOINT: ${{ secrets.APPWRITE_API_ENDPOINT || 'https://syd.cloud.appwrite.io/v1' }}
      APPWRITE_API_KEY: ${{ secrets.APPWRITE_API_KEY }}
      GIT_CFSUB_PAT: ${{ secrets.GIT_CFSUB_PAT }}

    steps:
      - name: 检查环境变量
        run: |
          if [ -z "$APPWRITE_PROJECT_ID" ]; then echo "::error::Secret 'APPWRITE_PROJECT_ID' 未设置！"; exit 1; fi
          if [ -z "$APPWRITE_SITE_ID" ]; then echo "::error::Secret 'APPWRITE_SITE_ID' 未设置！"; exit 1; fi
          if [ -z "$APPWRITE_REPO_ID" ]; then echo "::error::Secret 'APPWRITE_REPO_ID' 未设置！"; exit 1; fi
          if [ -z "$APPWRITE_API_KEY" ]; then echo "::error::Secret 'APPWRITE_API_KEY' 未设置！"; exit 1; fi
          if [ -z "$GIT_CFSUB_PAT" ]; then echo "::error::Secret 'GIT_CFSUB_PAT' 未设置！"; exit 1; fi
          echo "所有必要的 Secrets 都已加载。"

      - name: 获取部署状态
        id: get_status
        run: |
          echo "正在获取部署列表..."
          DEPLOYMENTS_JSON=$(curl -s --location --request GET "${APPWRITE_API_ENDPOINT}/sites/${APPWRITE_SITE_ID}/deployments" \
          --header "X-Appwrite-Project: ${APPWRITE_PROJECT_ID}" \
          --header "X-Appwrite-Key: ${APPWRITE_API_KEY}")
          
          # 查找所有失败部署的ID
          FAILED_DEPLOYMENT_IDS=$(echo "$DEPLOYMENTS_JSON" | jq -r '.deployments[] | select(.status == "failed") | ."$id"')
          
          # 查找所有进行中部署的ID
          BUILDING_DEPLOYMENT_IDS=$(echo "$DEPLOYMENTS_JSON" | jq -r '.deployments[] | select(.status == "building") | ."$id"')

          # 获取部署总数
          TOTAL_DEPLOYMENTS=$(echo "$DEPLOYMENTS_JSON" | jq -r '.total')
          
          if [ -n "$FAILED_DEPLOYMENT_IDS" ] || [ "$TOTAL_DEPLOYMENTS" -eq 0 ]; then
            if [ "$TOTAL_DEPLOYMENTS" -eq 0 ]; then
              echo "没有发现任何部署，将触发首次部署。"
            else
              echo "发现一个或多个失败的部署。"
            fi
            FAILED_IDS_ONELINE=$(echo "$FAILED_DEPLOYMENT_IDS" | tr '\n' ' ')
            BUILDING_IDS_ONELINE=$(echo "$BUILDING_DEPLOYMENT_IDS" | tr '\n' ' ')
            echo "failed_ids=${FAILED_IDS_ONELINE}" >> $GITHUB_OUTPUT
            echo "building_ids=${BUILDING_IDS_ONELINE}" >> $GITHUB_OUTPUT
            echo "status=redeploy" >> $GITHUB_OUTPUT
          elif [ -n "$BUILDING_DEPLOYMENT_IDS" ]; then
            echo "正在部署中，ID(s)：${BUILDING_DEPLOYMENT_IDS}"
            echo "status=building" >> $GITHUB_OUTPUT
          else
            echo "没有发现失败或进行中的部署，状态正常。"
            echo "status=ok" >> $GITHUB_OUTPUT
          fi

      - name: 触发新部署并清理
        if: steps.get_status.outputs.status == 'redeploy'
        run: |
          # 1. 触发新的部署
          echo "正在触发一次新的部署..."
          # 【调试修改】移除了 -s 参数，并增加了详细输出
          NEW_DEPLOYMENT_JSON=$(curl --verbose --location --request POST "${APPWRITE_API_ENDPOINT}/sites/${APPWRITE_SITE_ID}/deployments" \
          --header "Content-Type: application/json" \
          --header "X-Appwrite-Project: ${APPWRITE_PROJECT_ID}" \
          --header "X-Appwrite-Key: ${APPWRITE_API_KEY}" \
          --data-raw '{
              "providerRepositoryId": "'"$APPWRITE_REPO_ID"'",
              "providerBranch": "main",
              "activate": true
          }')
          
          # 【调试修改】打印出 Appwrite API 的原始响应
          echo "--- Appwrite API 响应 ---"
          echo "$NEW_DEPLOYMENT_JSON"
          echo "--------------------------"

          NEW_DEPLOYMENT_ID=$(echo "$NEW_DEPLOYMENT_JSON" | jq -r '."$id"')
          if [ -z "$NEW_DEPLOYMENT_ID" ] || [ "$NEW_DEPLOYMENT_ID" == "null" ]; then
            echo "::error::触发新部署失败！请检查上面的 API 响应以获取详细错误信息。"
            exit 1
          fi
          echo "已成功触发新部署，ID: ${NEW_DEPLOYMENT_ID}"

          # ... 后续步骤保持不变 ...
          # 2. 轮询获取新部署的日志并提取节点信息
          echo "等待构建日志生成..."
          BASE64_NODE=""
          for i in {1..10}; do
            sleep 10
            echo "正在获取日志 (尝试次数: $i)..."
            LOGS_OUTPUT=$(curl -s --location --request GET "${APPWRITE_API_ENDPOINT}/sites/${APPWRITE_SITE_ID}/deployments/${NEW_DEPLOYMENT_ID}/builds/1/logs" \
            --header "X-Appwrite-Project: ${APPWRITE_PROJECT_ID}" \
            --header "X-Appwrite-Key: ${APPWRITE_API_KEY}")
            BASE64_NODE=$(echo "$LOGS_OUTPUT" | jq -r '.logs' | grep -oE '[A-Za-z0-9+/=]{200,}' | head -n 1)
            if [ -n "$BASE64_NODE" ]; then
              echo "已成功从日志中提取节点信息！"
              break
            fi
          done

          if [ -z "$BASE64_NODE" ]; then
            echo "::error::超时：在100秒内未能从日志中提取到节点信息。"
            exit 1
          fi

          # 3. 将节点信息写入文件并推送到另一个仓库
          echo "正在将节点信息推送到 CFSub 仓库..."
          echo "$BASE64_NODE" > appwrite_base64.txt
          git clone https://x-access-token:${GIT_CFSUB_PAT}@github.com/yutian81/CFSub.git
          mv appwrite_base64.txt CFSub/nodes/
          cd CFSub
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add nodes/appwrite_base64.txt
          if git diff --staged --quiet; then
            echo "节点信息无变化，无需推送。"
          else
            git commit -m "自动更新 Appwrite 节点信息"
            git push
            echo "已成功将新节点信息推送到 CFSub 仓库。"
          fi
          cd ..

          # 4. 删除所有旧的、失败的和进行中的部署
          echo "正在清理所有旧的部署..."
          if [ -n "${{ steps.get_status.outputs.failed_ids }}" ]; then
            for FAILED_ID in ${{ steps.get_status.outputs.failed_ids }}; do
              echo "  - 正在删除失败的部署，ID: ${FAILED_ID}"
              curl -s --location --request DELETE "${APPWRITE_API_ENDPOINT}/sites/${APPWRITE_SITE_ID}/deployments/${FAILED_ID}" \
              --header "X-Appwrite-Project: ${APPWRITE_PROJECT_ID}" \
              --header "X-Appwrite-Key: ${APPWRITE_API_KEY}"
            done
          fi
          
          if [ -n "${{ steps.get_status.outputs.building_ids }}" ]; then
            for BUILDING_ID in ${{ steps.get_status.outputs.building_ids }}; do
              if [ "$BUILDING_ID" != "$NEW_DEPLOYMENT_ID" ]; then
                echo "  - 正在删除旧的进行中部署，ID: ${BUILDING_ID}"
                curl -s --location --request DELETE "${APPWRITE_API_ENDPOINT}/sites/${APPWRITE_SITE_ID}/deployments/${BUILDING_ID}" \
                --header "X-Appwrite-Project: ${APPWRITE_PROJECT_ID}" \
                --header "X-Appwrite-Key: ${APPWRITE_API_KEY}"
              else
                echo "  - 跳过删除新创建的部署，ID: ${BUILDING_ID}"
              fi
            done
          fi
          echo "已完成旧部署的清理。"

